import logging
from typing import Any, Optional

DEFAULT_TCP_LOGGING_PORT: int
DEFAULT_UDP_LOGGING_PORT: int
DEFAULT_HTTP_LOGGING_PORT: int
DEFAULT_SOAP_LOGGING_PORT: int
SYSLOG_UDP_PORT: int
SYSLOG_TCP_PORT: int


class BaseRotatingHandler(logging.FileHandler):
    mode: Any = ...
    encoding: Any = ...
    namer: Any = ...
    rotator: Any = ...

    def __init__(
        self, filename: Any, mode: Any, encoding: Optional[Any] = ..., delay: bool = ...
    ) -> None: ...
    def emit(self, record: Any) -> None: ...
    def rotation_filename(self, default_name: Any): ...
    def rotate(self, source: Any, dest: Any) -> None: ...


class RotatingFileHandler(BaseRotatingHandler):
    maxBytes: Any = ...
    backupCount: Any = ...

    def __init__(
        self,
        filename: Any,
        mode: str = ...,
        maxBytes: int = ...,
        backupCount: int = ...,
        encoding: Optional[Any] = ...,
        delay: bool = ...,
    ) -> None: ...
    stream: Any = ...
    def doRollover(self) -> None: ...
    def shouldRollover(self, record: Any): ...


class TimedRotatingFileHandler(BaseRotatingHandler):
    when: Any = ...
    backupCount: Any = ...
    utc: Any = ...
    atTime: Any = ...
    interval: int = ...
    suffix: str = ...
    extMatch: str = ...
    dayOfWeek: Any = ...
    rolloverAt: Any = ...

    def __init__(
        self,
        filename: Any,
        when: str = ...,
        interval: int = ...,
        backupCount: int = ...,
        encoding: Optional[Any] = ...,
        delay: bool = ...,
        utc: bool = ...,
        atTime: Optional[Any] = ...,
    ) -> None: ...
    def computeRollover(self, currentTime: Any): ...
    def shouldRollover(self, record: Any): ...
    def getFilesToDelete(self): ...
    stream: Any = ...
    def doRollover(self) -> None: ...


class WatchedFileHandler(logging.FileHandler):
    def __init__(
        self,
        filename: Any,
        mode: str = ...,
        encoding: Optional[Any] = ...,
        delay: bool = ...,
    ) -> None: ...
    stream: Any = ...
    def reopenIfNeeded(self) -> None: ...
    def emit(self, record: Any) -> None: ...


class SocketHandler(logging.Handler):
    host: Any = ...
    port: Any = ...
    address: Any = ...
    sock: Any = ...
    closeOnError: bool = ...
    retryTime: Any = ...
    retryStart: float = ...
    retryMax: float = ...
    retryFactor: float = ...
    def __init__(self, host: Any, port: Any) -> None: ...
    def makeSocket(self, timeout: int = ...): ...
    retryPeriod: Any = ...
    def createSocket(self) -> None: ...
    def send(self, s: Any) -> None: ...
    def makePickle(self, record: Any): ...
    def handleError(self, record: Any) -> None: ...
    def emit(self, record: Any) -> None: ...
    def close(self) -> None: ...


class DatagramHandler(SocketHandler):
    closeOnError: bool = ...
    def __init__(self, host: Any, port: Any) -> None: ...
    def makeSocket(self): ...
    def send(self, s: Any) -> None: ...


class SysLogHandler(logging.Handler):
    LOG_EMERG: int = ...
    LOG_ALERT: int = ...
    LOG_CRIT: int = ...
    LOG_ERR: int = ...
    LOG_WARNING: int = ...
    LOG_NOTICE: int = ...
    LOG_INFO: int = ...
    LOG_DEBUG: int = ...
    LOG_KERN: int = ...
    LOG_USER: int = ...
    LOG_MAIL: int = ...
    LOG_DAEMON: int = ...
    LOG_AUTH: int = ...
    LOG_SYSLOG: int = ...
    LOG_LPR: int = ...
    LOG_NEWS: int = ...
    LOG_UUCP: int = ...
    LOG_CRON: int = ...
    LOG_AUTHPRIV: int = ...
    LOG_FTP: int = ...
    LOG_LOCAL0: int = ...
    LOG_LOCAL1: int = ...
    LOG_LOCAL2: int = ...
    LOG_LOCAL3: int = ...
    LOG_LOCAL4: int = ...
    LOG_LOCAL5: int = ...
    LOG_LOCAL6: int = ...
    LOG_LOCAL7: int = ...
    priority_names: Any = ...
    facility_names: Any = ...
    priority_map: Any = ...
    address: Any = ...
    facility: Any = ...
    socktype: Any = ...
    unixsocket: bool = ...
    socket: Any = ...

    def __init__(
        self, address: Any = ..., facility: Any = ..., socktype: Optional[Any] = ...
    ) -> None: ...
    def encodePriority(self, facility: Any, priority: Any): ...
    def close(self) -> None: ...
    def mapPriority(self, levelName: Any): ...
    ident: str = ...
    append_nul: bool = ...
    def emit(self, record: Any) -> None: ...


class SMTPHandler(logging.Handler):
    username: Any = ...
    fromaddr: Any = ...
    toaddrs: Any = ...
    subject: Any = ...
    secure: Any = ...
    timeout: Any = ...

    def __init__(
        self,
        mailhost: Any,
        fromaddr: Any,
        toaddrs: Any,
        subject: Any,
        credentials: Optional[Any] = ...,
        secure: Optional[Any] = ...,
        timeout: float = ...,
    ) -> None: ...
    def getSubject(self, record: Any): ...
    def emit(self, record: Any) -> None: ...


class NTEventLogHandler(logging.Handler):
    appname: Any = ...
    dllname: Any = ...
    logtype: Any = ...
    deftype: Any = ...
    typemap: Any = ...

    def __init__(
        self, appname: Any, dllname: Optional[Any] = ..., logtype: str = ...
    ) -> None: ...
    def getMessageID(self, record: Any): ...
    def getEventCategory(self, record: Any): ...
    def getEventType(self, record: Any): ...
    def emit(self, record: Any) -> None: ...
    def close(self) -> None: ...


class HTTPHandler(logging.Handler):
    host: Any = ...
    url: Any = ...
    method: Any = ...
    secure: Any = ...
    credentials: Any = ...
    context: Any = ...

    def __init__(
        self,
        host: Any,
        url: Any,
        method: str = ...,
        secure: bool = ...,
        credentials: Optional[Any] = ...,
        context: Optional[Any] = ...,
    ) -> None: ...
    def mapLogRecord(self, record: Any): ...
    def emit(self, record: Any) -> None: ...


class BufferingHandler(logging.Handler):
    capacity: Any = ...
    buffer: Any = ...
    def __init__(self, capacity: Any) -> None: ...
    def shouldFlush(self, record: Any): ...
    def emit(self, record: Any) -> None: ...
    def flush(self) -> None: ...
    def close(self) -> None: ...


class MemoryHandler(BufferingHandler):
    flushLevel: Any = ...
    target: Any = ...
    flushOnClose: Any = ...

    def __init__(
        self,
        capacity: Any,
        flushLevel: Any = ...,
        target: Optional[Any] = ...,
        flushOnClose: bool = ...,
    ) -> None: ...
    def shouldFlush(self, record: Any): ...
    def setTarget(self, target: Any) -> None: ...
    buffer: Any = ...
    def flush(self) -> None: ...
    def close(self) -> None: ...


class QueueHandler(logging.Handler):
    queue: Any = ...
    def __init__(self, queue: Any) -> None: ...
    def enqueue(self, record: Any) -> None: ...
    def prepare(self, record: Any): ...
    def emit(self, record: Any) -> None: ...


class QueueListener:
    queue: Any = ...
    handlers: Any = ...
    respect_handler_level: Any = ...

    def __init__(
        self, queue: Any, *handlers: Any, respect_handler_level: bool = ...
    ) -> None: ...
    def dequeue(self, block: Any): ...
    def start(self) -> None: ...
    def prepare(self, record: Any): ...
    def handle(self, record: Any) -> None: ...
    def enqueue_sentinel(self) -> None: ...
    def stop(self) -> None: ...
